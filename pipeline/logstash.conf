input {
  http_poller {
    urls => {
      esql_query => {
        method => post
        url => "http://elasticsearch:9200/_query"
        headers => { "Content-Type" => "application/json" }
        body => '{
          "query": "FROM .ds-kibana_sample_data_logs-* | STATS count = COUNT(*), first_occurrence = MIN(@timestamp), last_occurrence = MAX(@timestamp) BY response | SORT response"
        }'
      }
    }
    request_timeout => 60
    schedule => { every => "60s" }
    codec => "json"
    metadata_target => "http_poller_metadata"
  }
}

filter {
  # Genera un evento por fila del array "values"
  split { field => "[values]" }

  # Mapear dinÃ¡micamente nombre de columnas -> valores
  ruby {
    code => '
      cols = event.get("columns")
      row  = event.get("values")
      if cols && row
        cols.each_with_index do |c,i|
          event.set(c["name"], row[i])
        end
      end
    '
  }

  # Convertir tipos
  mutate {
    convert => {
      "count" => "integer"
    }
  }

  # (Opcional) parsear timestamps a tipo date (crea @timestamp segÃºn last_occurrence)
  date {
    match => ["last_occurrence", "ISO8601"]
    target => "@timestamp"
    remove_field => []
  }

  # Eliminar todo lo que no sea los campos finales deseados
  mutate {
    remove_field => [
      "values",
      "columns",
      "http_poller_metadata",
      "host",
      "@version",
      "event",
      "agent"
    ]
  }
}

output {

  mongodb {
    uri => "mongodb://admin:1q2w3E*@mongodb:27017/?authSource=admin"
    database => "logsdb"
    collection => "grouped_response_code"
    isodate => true
    id => "%{response}"
  }

  stdout { codec => rubydebug }
}